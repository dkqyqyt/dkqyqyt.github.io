---
title: "알고리즘(CS)"
excerpt: "알고리즘에 관련된 CS 정리집"

categories:
- CS
tags:
- 알고리즘
---
## BigO

#### BigO의 개념
#### BigO의 복잡성 차트 보기

![image-20201025192711777](/assets/images/image-20201025192711777.png)

## DFS와 BFS의 차이

### 깊이 우선 탐색(DFS, Depth-First Search)



**DFS의 개념** : 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법

미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.

즉, 넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것이다.
- 사용하는 경우 : 모든 노드를 방문하고자 하는 경우에 이 방법을 선택한다.
- 깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 좀 더 간단하다.
- 단순 검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 느리다.

**DFS의 특징**

- 자기 자신을 호출하는 순환 알고리즘의 형태를 가지고 있다.
- 전위 순회(Pre-Order Traversals)를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다.
- 이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 어떤 노드를 방문했는지 여부를 반드시 검사해야 한다는 것이다. 이를 검사하지 않을 경우 무한루프에 빠질 수 있다.

  - DFS의 구현 방법 2가지
    1. 순환 호출 이용
    2. 명시적인 스택을 사용
       - 명시적인 스택을 사용하여 방문한 정점들을 스택에 저장하였다가 다시 꺼내어 작업한다.

### 너비 우선 탐색(BFS, Breadth-First Search)



**BFS의 개념** : 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법

시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.

즉, 깊게(deep) 탐색하기 전에 넓게(wide) 탐색하는 것이다.

- 사용하는 경우 : 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다. 
  - Ex) 지구상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Ash와 Vanessa 사이에 존재하는 경로를 찾는 경우
  - 깊이 우선 탐색의 경우 - 모든 친구 관계를 다 살펴봐야 할지도 모른다.
  - 너비 우선 탐색의 경우 - Ash와 가까운 관계부터 탐색
- 너비 우선 탐색(BFS)이 깊이 우선 탐색(DFS)보다 좀 더 복잡하다.

**BFS의 특징**

- 직관적이지 않은 면이 있다.
  - BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.
- BFS는 재귀적으로 동작하지 않는다.
- 이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다는 것이다.
  - 이를 검사하지 않을 경우 무한루프에 빠질 위험이 있다.
- BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 큐(Queue)를 사용한다.
  - 즉, 선입선출(FIFO) 원칙으로 탐색
  - 일반적으로 큐를 이용해서 반복적 형태로 구현하는 것이 가장 잘 동작한다.
- 'Prim', 'Dijkstra' 알고리즘과 유사하다.

## Fibonacci에서의 재귀 동적프로그래밍 반복의 세 가지 방식에 대한 시간복잡도와 공간복잡도

1. 재귀
2. 동적 프로그래밍
3. 반복

## 정렬 알고리즘의 종류와 개념

### 버블 정렬



서로 인접한 두 원소를 검사하여 정렬하는 알고리즘

선택 정렬과 기본 개념이 유사하다.

**장점**

- 구현이 매우 간단하다.

**단점**

- 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
- 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
- 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.

```python
def bubble_sort(arr):
    for i in range(len(arr)-1,0,-1):
        for j in range(i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```

### 삽입 정렬



손안의 카드를 정렬하는 방법과 유사하다.

- 새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리를 찾아 삽입한다.
- 새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다.

자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘

매 순서마다 해당  원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.

**장점**

안정한 정렬 방법.

레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.

대부분의 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.

**단점**

비교적 많은 레코드의 이동을 포함한다.

레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.

```python
def insertion_sort(arr):
    for i in range(1,len(arr)):
        key = arr[i]
        for j in range(i-1,-1,-1):
            if arr[j] > key:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```

### 선택 정렬



제자리 정렬 알고리즘 중 하나

입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법

해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘

- 첫 번째 순서에는 첫 번째 위치에 가장 최솟값을 넣는다.
- 두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.
- ...

**과정 설명**

1. 주어진 배열 중에서 최솟값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다.
3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
4. 하나의 원소만 남을 때가지 위의 1~3 과정을 반복한다.

**장점**

- 자료 이동 횟수가 미리 결정된다.

**단점**

- 안정성을 만족하지 않는다.
- 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.

```python
def selection_sort(arr):
    for i in range(len(arr)-1):
        min_idx = i
        for j in range(i+1,len(arr)):
            if arr[min_idx] > arr[j]:
                min_idx = j
        if i != min_idx:
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
```

### 합병 정렬



'존 폰 노이만'이라는 사람이 제안한 방법

일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다.

- 분할 정복 방법
  - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
  - 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.

**과정 설명**

1. 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
2. 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
3. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
4. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

**장점**

- 안정적인 정렬 방법
  - 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다.
- 만약 레코드를 연결리스트로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
  - 제자리 정렬로 구현할 수 있다.
- 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적이다.

**단점**

- 만약 레코드를 배열로 구성하면, 임시 배열이 필요하다.
  - 제자리 정렬이 아니다.
- 레코드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.

```python
def merge(left_arr, right_arr):
    result = []
    left_idx = 0
    right_idx = 0
    while left_idx < len(left_arr) or right_idx < len(right_arr):
        if left_idx >= len(left_arr):
            result.extend(right_arr)
            break
        if right_idx >= len(right_arr):
            result.extend(left_arr)
            break
        if left_arr[left_idx] <= right_arr[right_idx]:
            result.append(left_arr[left_idx])
            left_idx += 1
        else:
            result.append(right_arr[right_idx])
            right_idx += 1
    return result

def merge_sort(arr):
    if len(arr) == 1:
        return arr
    mid = len(arr)//2
    left_arr = arr[:mid]
    right_arr = arr[mid:]
    left_arr = merge_sort(left_arr)
    right_arr = merge_sort(right_arr)
    return merge(left_arr,right_arr)
```

### 퀵 정렬



'찰스 앤터니 리처드 호어'가 개발한 정렬 알고리즘

퀵 정렬은 불안정 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.

분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법

- 합병 정렬과 달리 퀵 정렬은 리스트를 비균등하게 분할한다.

**과정 설명**

1. 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot)이라고 한다.

2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. 

3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.

   - 분할된 부분 리스트에 대하여 순환 호출을 이용하여 정렬을 반복한다.

   - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복

4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.

   - 리스트의 크기가 0이나 1이 될 때까지 반복

**장점**

- 속도가 빠르다.
  - 시간 복잡도가 O(nlogn)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
- 추가 메모리 공간을 필요로 하지 않는다.
  - 퀵 정렬은 O(logn) 만큼의 메모리를 필요로 한다.

**단점**

- 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

```python
def quick_sort(arr, left, right):
   l = left
   r = right
   pivot = arr[(left+right)//2]
  
   while l<=r :
       print(l,r)
       while arr[l] < pivot:
           l += 1
       while arr[r] > pivot:
           r -= 1
       if l <= r:
           arr[l], arr[r] = arr[r], arr[l]
           l += 1
           r -= 1
   if l < right:
       quick_sort(arr,l,right)
   if r > left:
       quick_sort(arr, left, r)
  
   return arr
```

### 힙 정렬



완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조

최댓값, 최솟값을 쉽게 추출할 수 있는 자료구조

**장점**

- 시간 복잡도가 좋은 편
- 힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때이다.

```python
def heapify(arr, idx):
    small = idx
    if idx*2 < len(arr) and arr[idx*2] < arr[small]:
        small = idx*2
    if idx*2 + 1< len(arr) and arr[idx*2+1] < arr[small]:
        small = idx*2 + 1
    if small != idx:
        arr[small], arr[idx] = arr[idx], arr[small]
        heapify(arr,small)

def heap_sort(arr):
    arr = [0] + arr
    for i in range(len(arr)//2,0,-1):
        heapify(arr,i)
    my_arr = []
    for i in range(1,len(arr)):
        if len(arr) == 2:
            my_arr.append(arr[1])
            break
        my_arr.append(arr[1])
        arr[1] = arr.pop()
        heapify(arr,1)
    return my_arr
```



## MST(Minimum Spanning Tree)

### Spanning Tree란



그래프 내의 모든 정점을 포함하는 트리, Spanning Tree = 신장 트리 = 스패닝 트리

Spanning Tree는 그래프의 최소 연결 부분 그래프이다.
- 최소 연결 = 간선의 수가 가장 적다.
- n개의 정점을 가지는 그래프의 최소 간선의 수는 (n-1)개이고, (n-1)개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 바로 Spanning Tree가 된다.

즉, 그래프에서 일부 간선을 선택해서 만든 트리

**Spanning Tree의 사용 사례**

- 통신 네트워크의 구축
  - 예를 들어, 회사 내의 모든 전화기를 가장 적은 수의 케이블을 사용하여 연결하고자 하는 경우
  - n개의 위치를 연결하는 통신 네트워크를 최소의 링크(간선)를 이용하 구축하고자 하는 경우, 최소 링크의 수는 (n-1)개가 되고, 따라서 Spanning Tree가 가능해진다.

### MST(Minimum Spanning Tree, 최소 신장 트리)란



Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리, MST = Minimum Spanning Tree = 최소 신장 트리
- 각 간선의 가중치가 동일하지 않을 때 단순히 가장 적은 간선을 사용한다고 해서 최소 비용이 얻어지는 것은 아니다.
- MST는 간선의 가중치를 고려하여 최소 비용의 Spanning Tree를 선택하는 것을 말한다.
- 즉, 네트워크(가중치를 간선에 할당한 그래프)에 있는 모든 정점들을 가장 적은 수의 간선과 비용으로 연결하는 것이다.

**MST의 특징**

- i. 간선의 가중치의 합이 최소여야 한다.
- ii. n개의 정점을 가지는 그래프에 대해 반드시 (n-1)개의 간선만을 사용해야 한다.
- iii. 사이클이 포함되어서는 안된다.

**MST의 사용 사례**

- 통신망, 도로망, 유통망에서 길이, 구축 비용, 전송 시간 등을 최소로 구축하려는 경우
  - 도로 건설 : 도시들을 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제
  - 전기 회로 : 단자들을 모두 연결하면서 전선의 길이가 가장 최소가 되도록 하는 문제
  - 통신 : 전화선의 길이가 최소가 되도록 전화 케이블 망을 구성하는 문제
  - 배관 : 파이프를 모두 연결하면서 파이프의 총 길이가 최소가 되도록 연결하는 문제
  
  

## Kruskal MST 알고리즘

탐욕적인 방법(greedy method)을 이용하여 네트워크 (가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것
- MST(최소 비용 신장 트리)가 1) 최소 비용의 간선으로 구성됨 2) 사이클을 포함하지 않음 의 조건에 근거하여 각 단계에서 사이클을 이루지 않는 최소 비용 간선을 선택한다.
- 간선 선택을 기반으로 하는 알고리즘이다.
- 이전 단계에서 만들어진 신장 트리와는 상관없이 무조건 최소 간선만을 선택하는 방법이다.

**과정**

1. 그래프의 간선들을 가중치의 오름차순으로 정렬한다.

2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.

   - 즉, 가장 낮은 가중치를 먼저 선택하다.

   - 사이클을 형성하는 간선을 제외한다.

3. 해당 간선을 현재의 MST(최소 비용 신장 트리)의 집합에 추가한다.



## Prim MST 알고리즘

시작 정점에서부터 출발하여 신장트리 집합을 단계적으로 확장해나가는 방법
- 정점 선택을 기반으로 하는 알고리즘이다.
- 이전 단계에서 만들어진 신장 트리를 확장하는 방법이다.

**과정**

1. 시작 단계에서는 시작 정점만이 MST(최소 비용 신장 트리) 집합에 포함된다.
2. 앞 단계에서 만들어진 MST 집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선책하여 트리를 확장한다.
   - 즉, 가장 낮은 가중치를 먼저 선택한다.
3. 위의 과정을 트리가 (N-1)개의 간선을 가질 때까지 반복한다.

