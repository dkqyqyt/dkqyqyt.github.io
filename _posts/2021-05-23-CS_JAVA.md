---
title: "JAVA(CS)"
excerpt: "JAVA에 관련된 CS 정리집"

categories:
- CS
tags:
- JAVA
- 자바
---
## JAVA

### Java 프로그래밍이란

---

### Java SE와 Java EE 애플리케이션 차이

---

### java와 c/c++의 차이점

- java와 c/c++의 가장 큰 차이점은 실행 환경이다.
- java에서의 개발 : 컴파일 혹은 컴파일 + jar 압축
  - 자바는 링크 과정이 없이 컴파일러가 바로 바이트 코드를 생성
- c/c++에서의 개발 : 컴파일 + 링크

---

### java 언어의 장단점

- 장점
  - 운영체제에 독립적이다.
    - JVM에서 동작하기 때문에, 특정 운영체제에 종속되지 않는다.
  - 객체지향 언어이다.
    - 객체지향적으로 프로그래밍 하기 위해 여러 언어적 지원을 하고 있다. (캡슐화, 상속, 추상화, 다형성 등)
    - 객체지향 패러다임의 특성상 비교적 이해하고 배우기 쉽다.
  - 자동으로 메모리 관리를 해준다.
    - JVM에서 Garbage Collector라고 불리는 데몬 쓰레드에 의해 GC(Garbage Collection)이 일어난다. GC로 인해 별도의 메모리 관리가 필요 없으며 비지니스 로직에 집중할 수 있다.
  - 오픈 소스이다.
    - 정확히 말하면 OpenJDK가 오픈소스이다. OracleJDK는 사용 목적에 따라서 유료가 될 수 있다.
    - 많은 Java 개발자가 존재하고 생태계가 잘 구축되어 있다. 덕분에 오픈소스 라이브러리가 풍부하며 잘 활용한다면 짧은 개발 시간 내에 안정적인 애플리케이션을 쉽게 구현할 수 있다.
  - 멀티스레드를 쉽게 구현할 수 있다.
    - 자바는 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 실행되는 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있다.
  - 동적 로딩을 지원한다.
    - 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성한다. 또한 유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다. 따라서 유지보수가 쉽고 빠르다.
- 단점
  - 비교적 속도가 느리다.
    - 자바는 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고, JVM에 의해 기계어로 번역되고 실행하는 과정을 거치지 때문에 C나 C++의 컴파일 단계에서 만들어지는 완전한 기계어보다는 속도가 느리다. 그러나 하드웨어 성능 향상과 바이트 코드를 기계어로 변환해주는 JIT 컴파일러 같은 기술 적용으로 JVM의 기능이 향상되어 속도의 격차가 많이 줄었다.
  - 예외처리가 불편하다.
    - 프로그래머 검사가 필요한 예외가 등장한다면 무조건 프로그래머가 선언을 해줘야한다.

---

### java의 접근 제어자의 종류와 특징

- public 
  - 표시 : +
  - 어떤 클래스의 객체에서든 접근 가능
- private 
  - 표시 : -
  - 이 클래스에서 생성된 객체들만 접근 가능
- protected
  - 표시 : #
  - 이 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능
- package
  - 표시 : ~
  - 동일 패키지에 있는 클래스의 객체들만 접근 가능

---

### java의 데이터 타입

1. 기본 데이터 타입(Primitive Data Type)
   - 기본 타입의 종류는 byte, short, char, int, float, double, boolean이 있다.
     - 정수형 : byte, short, int, long
     - 실수형 : float, double
     - 논리형 : boolean(true/false)
     - 문자형 : char
   - 기본 타입의 크기가 작고 고정적이기 때문에 메모리의 Stack 영역에 저장된다.
2. 참조 타입(Reference Data Type)
   - 참조 타입의 종류는 class, array, interface, Enumeration이 있다.
     - 기본형을 제외하고는 모두 참조형이다.
     - new 키워드를 이용하여 객체를 생성하여 데이터가 생성된 주소를 참조하는 타입이다.
     - String, StringBuffer, List, 개인이 만든 클래스 등
     - String과 배열은 참조 타입과 달리 new 없이 생성이 가능하지만 기본 타입이 아닌 참조 타입이다.
   - 참조 타입의 데이터의 크기가 가변적, 동적이기 때문에 동적으로 관리되는 Heap 영역에 저장된다.
   - 더 이상 참조하는 변수가 없을 때 가비지 컬렉션에 의해 파괴된다.
   - 참조 타입은 값이 저장된 곳의 주소를 저장하는 공간으로 객체의 주소를 저장한다. (Call-By-Value)

---

### Wrapper class

프로그램에 따라 기본 타입의 데이터를 객체로 취급해야하는 경우가 있다. 예를 들어, 메소드의 인수로 객체 타입만이 요구되면, 기본 타입의 데이터를 그대로 사용할 수는 없다. 이때 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 한다.

- 자바에서 제공하는 Wrapper class
  - byte : Byte
  - short : Short
  - int : Integer
  - long : Long
  - float : Float
  - double : Double
  - char : Character
  - boolean : Boolean

이렇게 8개의 기본 타입에 해당하는 데이터를 객체로 포장해주는 클래스를 래퍼클래스라고 한다. 래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어 준다. 이러한 래퍼 클래스는 모두 java.lang 패키지에 포함되어 제공된다.

- 박싱, 언박싱
  - 래퍼 클래스는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없다. 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있다.
  - 래퍼 클래스의 인스턴스로 변환하는 과정을 박싱, 래퍼 클래스의 인스턴스로 저장된 값을 다시 기본 타입의 데이터로 꺼내는 과정을 언박싱이라 한다.

---

### OOP의 4가지 특징

1. 추상화
   - 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념으로 다루는 것

2. 캡슐화
   - 정보 은닉 : 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것
   - 높은 응집도, 낮은 결합도를 유지하여 유연함과 유지보수성 증가
3. 일반화 관계
   - 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정
4. 다형성
   - 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
   - 오버라이딩, 오버로딩
   - Overriding
     - 임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때, 상위 클래스 또는 인터페이스에 정의되어 있는 메소드를 재정의하여 사용하는 것
     - 메소드 호출 시 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다.
   - Overloading
     - 메소드에 주어진 인자에 따라 동작을 다르게 구현할 수 있다.
     - 코드의 중복이 줄어들고, 가독성이 늘어난다.
     - 반환형은 관계 없지만, 인자의 갯수, 인자의 타입에 따라 다르게 구현할 수 있다.

---

### OOP의 5대 원칙

"SOLID" 원칙

- S : 단일 책임 원칙 (SRP, Single Responsibility Principle)
  - 객체는 단 하나의 책임만 가져야 한다.
- O : 개방-폐쇄 원칙(OCP, Open Closed Principle)
  - 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
- L : 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  - 일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
- I : 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  - 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다.
- D : 의존 역전 원칙 (DIP, Dependency Inversion Principle)
  - 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.

---

### 객체지향 프로그래밍과 절차지향 프로그래밍의 차이

- 절차지향 프로그래밍
  - 실행하고자 하는 절차를 정하고, 이 절차대로 프로그래밍하는 방법
  - 목적을 달성하기 위한 일의 흐름에 중점을 둔다.
- 객체지향 프로그래밍
  - 실세상의 물체를 객체로 표현하고, 이들 사이의 관계, 상호 작용을 프로그램으로 나타낸다.
  - 객체를 추출하고 객체들의 관계를 결정하고 이들의 상호 작용에 필요한 함수(메소드)와 변수(필드)를 설계 및 구현한다.
  - 객체 지향의 핵심은 연관되어 있는 변수와 메소드를 하나의 그룹으로 묶어서 그룹핑하는 것이다.
  - 사람의 사고와 가장 비슷하게 프로그래밍 하기 위해서 생성된 기법
  - 하나의 클래스를 바탕으로 서로 다른 상태를 가진 인스턴스를 만들면 서로 다른 행동을 하게 된다. 즉, 하나의 클래스가 여러 개의 인스턴스가 될 수 있다는 점이 객체 지향이 제공하는 가장 기본적인 재활용성이라고 할 수 있다.

---

### 객체 지향이란

- 객체(Object)
  - 현실세계의 실체 및 개념을 반영하는 상태(Status)와 행위(Behavior)를 정의한 데이터의 집합
- 객체지향 프로그래밍
  - 각자의 역할을 지닌 객체들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍하는 것

- 장점
  - 사람의 관점에서 프로그램을 이해하고 파악하기 쉽다.
  - 강한 응집력과 약한 결합력을 가진다.
  - 재사용성, 확장성, 융통성이 높다.
  - 디버깅과 유지보수가 용이하고 설계와 분석이 비교적 쉽다.
- 단점
  - 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead가 발생한다.
    - 처리 속도가 상대적으로 느리다.
    - 하드웨어의 발전으로 이 단점은 어느정도 해소되었다.
  - 객체가 상태를 갖기 때문에 예상치 못한 부작용이 발생할 수 있다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킬 수 있다.
    - 함수형 프로그래밍 등장의 패러다임

---

### non-static 멤버와 static 멤버의 차이

- non-static 멤버
  - 공간적 특성 : 멤버는 객체마다 별도로 존재한다.
    - 인스턴스 멤버라고 부름
  - 시간적 특성 : 객체 생성 시에 멤버가 생성된다.
    - 객체가 생길 때 멤버도 생성된다.
    - 객체 생성 후 멤버 사용이 가능하다.
    - 객체가 사라지면 멤버도 사라진다.
  - 공유의 특성 : 공유되지 않는다.
    - 멤버는 객체 내에 각각의 공간을 유지한다.
- static 멤버
  - 공간적 특성 : 멤버는 클래스당 하나가 생성된다.
    - 멤버는 객체 내부가 아닌 별도의 공간에 생성된다.
    - 클래스 멤버라고 부른다.
  - 시간적 특성 : 클래스 로딩 시에 멤버가 생성된다.
    - 객체가 생기기 전에 이미 생성된다.
    - 객체가 생기기 전에도 사용이 가능하다. (즉, 객체를 생성하지 않고도 사용할 수 있다.)
    - 객체가 사라져도 멤버는 사라지지 않는다.
    - 멤버는 프로그래밍 종료될 때 사라진다.
  - 공유의 특성 : 동일한 클래스의 모든 객체들에 의해 공유된다.

---

### java의 가비지 컬렉션 처리 방법

- java의 가비지 컬렉션 처리 방법

  - GC 작업을 수행하는 가비지 콜렉터가 하는 일
    - 메모리 할당
    - 사용 중인 메모리 인식
    - 미사용 메모리 인식

  ![image-20201026124115976](/assets/images/image-20201026124115976.png)

  - 가비지 콜렉터가 들르는 메모리 영역은 Young 영역에 포함되는 Eden, Survivor1, Survivor2와 Old 영역
  - Young 영역에 있는 객체는 각 하위 영역이 가득 차면 Miner GC가 동작하여 더이상 참조되지 않는 객체 제거
  - Old 영역에 있는 객체는 영역이 가득 차면 Major GC(Full GC)가 동작하여 더이상 참조되지 않는 객체 제거
  - 동작 과정
    - 객체를 최초 생성하면 Young 영역 중 Eden 영역에 위치
    - Eden 영역에서 Miner GC 발생 시, 참조 중인 객체라면 Survivor1로 이동
    - Survivor1에서 Miner GC 발생 시, 참조 중인 객체라면 Survivor2로 이동
    - Survivor2에서 Miner GC 발생 시, 참조 중인 객체라면 다시 Survivor1 영역으로 이동 (Survivor1 <--> 2 반복)
    - Survivor 영역이 가득 차거나 Young 영역에서 오래 살아남은 객체는 Old 영역으로 이동
      - '오래'의 기준은 객체마다 age bit라는 것을 가지고 있는데 이는 Miner GC에서 살아남은 횟수를 기록하는 값
    - Old 영역에 있는 객체는 Major GC가 발생했을 때 참조 여부에 따라 공간이 유지되거나 제거